<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Very Good Graphics Blog</title><link>https://blog.verygoodgraphics.com/posts/</link><description>Recent content in Posts on Very Good Graphics Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>VeryGoodGraphics</copyright><lastBuildDate>Thu, 29 Sep 2022 15:36:14 +0800</lastBuildDate><atom:link href="https://blog.verygoodgraphics.com/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Digging into Compiling C++ to WebAssembly</title><link>https://blog.verygoodgraphics.com/posts/cpp-wasm/</link><pubDate>Thu, 29 Sep 2022 15:36:14 +0800</pubDate><guid>https://blog.verygoodgraphics.com/posts/cpp-wasm/</guid><description>&lt;p>The support of WebAssembly is a critical part of VGG engine, as we&lt;/p>
&lt;ul>
&lt;li>not only compile the whole engine to WebAssembly for running in browsers;&lt;/li>
&lt;li>but also support user-generated wasm file in combination with designs to make a whole interactive app&lt;/li>
&lt;/ul>
&lt;p>By definition,&lt;/p>
&lt;blockquote>
&lt;p>WebAssembly is an executable binary format for a stack-based virtual machine.&lt;/p>
&lt;/blockquote>
&lt;p>and there have been so many blog posts, papers, and books help us disect the WebAssembly format. However, seldom articles talk about the compiling process of C++ programs to WebAssembly. Because there is a &lt;em>de-facto&lt;/em> tool called &lt;a href="https://emscripten.org/">Emscripten&lt;/a> which is devoted to this problem.&lt;/p>
&lt;p>And nobody seems to have interest in the underlying mechanism of Emscripten.&lt;/p>
&lt;p>In this article, we kept the record for digging into the compiling process from C++ to WebAssembly, thus demystifying Emscripten. Hope you enjoy it!&lt;/p></description></item><item><title>ECS Architecture for GUI applications</title><link>https://blog.verygoodgraphics.com/posts/ecs/</link><pubDate>Wed, 14 Sep 2022 21:28:17 +0800</pubDate><guid>https://blog.verygoodgraphics.com/posts/ecs/</guid><description>&lt;p>ECS, short for Entity-Component-System, is an architectural design pattern originally found in the video game programming. It is a powerful technique that allows easing the programming headaches as well as boosting the performance of a game containing huge amount of interactive objects.&lt;/p>
&lt;p>That&amp;rsquo;s why the VGG engine takes ECS as the fundamental architecture, because VGG targets for high performance in the very beginning. However, VGG is more about making interactive applications, particularly the GUI applications. &lt;a name="initial-problem">&lt;/a>&lt;strong>Would the ECS architecture still be suitable for such a task?&lt;/strong> Let&amp;rsquo;s dive a little deeper.&lt;/p></description></item><item><title>Introducing VGG and Design-as-Code</title><link>https://blog.verygoodgraphics.com/posts/intro-vgg/</link><pubDate>Thu, 12 May 2022 17:38:17 +0800</pubDate><guid>https://blog.verygoodgraphics.com/posts/intro-vgg/</guid><description>&lt;p>VGG is yet another engine and framework for making interactive apps, which emphasizes the concept of &lt;em>Design-as-Code&lt;/em> at its core. And it may hopefully unite the worlds of design and code at last.&lt;/p>
&lt;p>Meanwhile, the whole world is about using Web technologies, platform-specific frameworks, or cross-platform frameworks, to make apps, the most famous and innovative among them being &lt;a href="https://flutter.dev/">Flutter&lt;/a>, which takes advantage of underlying parts of browser engine to achieve the goal of &amp;ldquo;Write Once, Run Anywhere&amp;rdquo;&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>.&lt;/p>
&lt;p>So why do we need another engine or framework? That&amp;rsquo;s what we need to explain about Design-as-Code, but let&amp;rsquo;s look at other choices first.&lt;/p></description></item></channel></rss>